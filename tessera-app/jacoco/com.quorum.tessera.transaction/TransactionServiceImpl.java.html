<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TransactionServiceImpl.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">tessera-app</a> &gt; <a href="index.source.html" class="el_package">com.quorum.tessera.transaction</a> &gt; <span class="el_source">TransactionServiceImpl.java</span></div><h1>TransactionServiceImpl.java</h1><pre class="source lang-java linenums">package com.quorum.tessera.transaction;

import com.quorum.tessera.enclave.model.MessageHash;
import com.quorum.tessera.key.KeyManager;
import com.quorum.tessera.nacl.Key;
import com.quorum.tessera.nacl.NaclFacade;
import com.quorum.tessera.nacl.Nonce;
import com.quorum.tessera.transaction.exception.TransactionNotFoundException;
import com.quorum.tessera.transaction.model.EncodedPayload;
import com.quorum.tessera.transaction.model.EncodedPayloadWithRecipients;
import com.quorum.tessera.transaction.model.EncryptedTransaction;
import org.bouncycastle.jcajce.provider.digest.SHA3;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.transaction.Transactional;
import java.util.Collection;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

import static java.util.stream.Collectors.toList;

@Transactional
public class TransactionServiceImpl implements TransactionService {

<span class="fc" id="L27">    private static final Logger LOGGER = LoggerFactory.getLogger(TransactionServiceImpl.class);</span>

    private final EncryptedTransactionDAO encryptedTransactionDAO;

    private final PayloadEncoder payloadEncoder;

    private final KeyManager keyManager;

    private final NaclFacade nacl;

    public TransactionServiceImpl(final EncryptedTransactionDAO encryptedTransactionDAO,
                                  final PayloadEncoder payloadEncoder,
                                  final KeyManager keyManager,
<span class="fc" id="L40">                                  final NaclFacade nacl) {</span>
<span class="fc" id="L41">        this.encryptedTransactionDAO = Objects.requireNonNull(encryptedTransactionDAO);</span>
<span class="fc" id="L42">        this.payloadEncoder = Objects.requireNonNull(payloadEncoder);</span>
<span class="fc" id="L43">        this.keyManager = Objects.requireNonNull(keyManager);</span>
<span class="fc" id="L44">        this.nacl = Objects.requireNonNull(nacl);</span>
<span class="fc" id="L45">    }</span>

    @Override
    public void delete(final MessageHash hash) {
<span class="fc" id="L49">        LOGGER.info(&quot;Received request to delete message with hash {}&quot;, hash);</span>
<span class="fc" id="L50">        this.encryptedTransactionDAO.delete(hash);</span>
<span class="fc" id="L51">    }</span>

    @Override
    public Collection&lt;EncodedPayloadWithRecipients&gt; retrieveAllForRecipient(final Key recipientPublicKey) {
<span class="fc" id="L55">        LOGGER.debug(&quot;Retrieving all transaction for recipient {}&quot;, recipientPublicKey);</span>

<span class="fc" id="L57">        return encryptedTransactionDAO</span>
<span class="fc" id="L58">            .retrieveAllTransactions()</span>
<span class="fc" id="L59">            .stream()</span>
<span class="fc" id="L60">            .map(EncryptedTransaction::getEncodedPayload)</span>
<span class="fc" id="L61">            .map(payloadEncoder::decodePayloadWithRecipients)</span>
<span class="fc" id="L62">            .filter(payload -&gt; payload.getRecipientKeys().contains(recipientPublicKey))</span>
<span class="fc" id="L63">            .collect(toList());</span>
    }

    @Override
    public EncodedPayloadWithRecipients retrievePayload(final MessageHash hash) {
<span class="fc" id="L68">        return encryptedTransactionDAO</span>
<span class="fc" id="L69">            .retrieveByHash(hash)</span>
<span class="fc" id="L70">            .map(EncryptedTransaction::getEncodedPayload)</span>
<span class="fc" id="L71">            .map(payloadEncoder::decodePayloadWithRecipients)</span>
<span class="fc" id="L72">            .orElseThrow(() -&gt; new TransactionNotFoundException(&quot;Message with hash &quot; + hash + &quot; was not found&quot;));</span>
    }

    @Override
    public byte[] retrieveUnencryptedTransaction(final MessageHash hash, final Key providedKey) {

<span class="fc" id="L78">        final EncryptedTransaction encryptedTransaction = encryptedTransactionDAO</span>
<span class="fc" id="L79">            .retrieveByHash(hash)</span>
<span class="fc" id="L80">            .orElseThrow(() -&gt; new TransactionNotFoundException(&quot;Message with hash &quot; + hash + &quot; was not found&quot;));</span>

<span class="fc" id="L82">        final EncodedPayloadWithRecipients payloadWithRecipients</span>
<span class="fc" id="L83">            = payloadEncoder.decodePayloadWithRecipients(encryptedTransaction.getEncodedPayload());</span>

<span class="fc" id="L85">        final EncodedPayload encodedPayload = payloadWithRecipients.getEncodedPayload();</span>

        final Key senderPubKey;
       
        final Key recipientPubKey;

<span class="fc bfc" id="L91" title="All 2 branches covered.">        if (!keyManager.getPublicKeys().contains(encodedPayload.getSenderKey())) {</span>
            // This is a payload originally sent to us by another node
<span class="fc" id="L93">            recipientPubKey = encodedPayload.getSenderKey();</span>
<span class="fc" id="L94">            senderPubKey = providedKey;</span>
        } else {
            // This is a payload that originated from us
<span class="fc" id="L97">            senderPubKey = encodedPayload.getSenderKey();</span>
<span class="fc" id="L98">            recipientPubKey = payloadWithRecipients.getRecipientKeys().get(0);</span>
        }

<span class="fc" id="L101">        final Key senderPrivKey = keyManager.getPrivateKeyForPublicKey(senderPubKey);</span>
<span class="fc" id="L102">        final Key sharedKey = nacl.computeSharedKey(recipientPubKey, senderPrivKey);</span>

        try {
<span class="fc" id="L105">            final byte[] recipientBox = encodedPayload.getRecipientBoxes().iterator().next();</span>
<span class="fc" id="L106">            final Nonce nonce =  encodedPayload.getRecipientNonce();</span>
<span class="fc" id="L107">            final byte[] masterKeyBytes = nacl.openAfterPrecomputation(recipientBox,nonce, sharedKey);</span>

<span class="fc" id="L109">            final Key masterKey = new Key(masterKeyBytes);</span>

<span class="fc" id="L111">            final byte[] cipherText = encodedPayload.getCipherText();</span>
<span class="fc" id="L112">            final Nonce cipherTextNonce = encodedPayload.getCipherTextNonce();</span>

<span class="fc" id="L114">            return nacl.openAfterPrecomputation(cipherText, cipherTextNonce, masterKey);</span>

<span class="fc" id="L116">        } catch (final RuntimeException ex) {</span>
<span class="fc" id="L117">            LOGGER.info(&quot;Couldn't decrypt message with hash {}. Our public key is: {}&quot;, hash, senderPubKey);</span>
<span class="fc" id="L118">            LOGGER.debug(&quot;RuntimeException: &quot;, ex);</span>
<span class="fc" id="L119">            throw ex;</span>
        }

    }

    @Override
    public MessageHash storeEncodedPayload(final EncodedPayloadWithRecipients payloadWithRecipients) {

<span class="fc" id="L127">        final SHA3.DigestSHA3 digestSHA3 = new SHA3.Digest512();</span>
<span class="fc" id="L128">        final byte[] digest = digestSHA3.digest(payloadWithRecipients.getEncodedPayload().getCipherText());</span>

<span class="fc" id="L130">        final MessageHash transactionHash = new MessageHash(digest);</span>

<span class="fc" id="L132">        LOGGER.info(&quot;Generated transaction hash {}&quot;, transactionHash);</span>

<span class="fc" id="L134">        final EncryptedTransaction newTransaction = new EncryptedTransaction(</span>
            transactionHash,
<span class="fc" id="L136">            this.payloadEncoder.encode(payloadWithRecipients)</span>
        );

<span class="fc" id="L139">        this.encryptedTransactionDAO.save(newTransaction);</span>

<span class="fc" id="L141">        return transactionHash;</span>
    }

    @Override
    public EncodedPayloadWithRecipients encryptPayload(final byte[] message,
                                                       final Key senderPublicKey,
                                                       final List&lt;Key&gt; recipientPublicKeys) {

<span class="fc" id="L149">        final Key masterKey = nacl.createSingleKey();</span>
<span class="fc" id="L150">        final Nonce nonce = nacl.randomNonce();</span>
<span class="fc" id="L151">        final Nonce recipientNonce = nacl.randomNonce();</span>

<span class="fc" id="L153">        final byte[] cipherText = nacl.sealAfterPrecomputation(message, nonce, masterKey);</span>

<span class="fc" id="L155">        final Key privateKey = keyManager.getPrivateKeyForPublicKey(senderPublicKey);</span>

<span class="fc" id="L157">        final List&lt;byte[]&gt; encryptedMasterKeys = recipientPublicKeys</span>
<span class="fc" id="L158">            .stream()</span>
<span class="fc" id="L159">            .map(key -&gt; nacl.computeSharedKey(key, privateKey))</span>
<span class="fc" id="L160">            .map(key -&gt; nacl.sealAfterPrecomputation(masterKey.getKeyBytes(), recipientNonce, key))</span>
<span class="fc" id="L161">            .collect(Collectors.toList());</span>

<span class="fc" id="L163">        return new EncodedPayloadWithRecipients(</span>
            new EncodedPayload(senderPublicKey, cipherText, nonce, encryptedMasterKeys, recipientNonce),
            recipientPublicKeys
        );

    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span></div></body></html>